    use self::Instruction::*;
    use registers::*;

    #[allow(non_camel_case_types)]
    #[derive(Clone, Copy)]
    pub enum Instruction {
        ADC_A_d8,
        ADC_A_HL,
        ADC_A_r(Register),
        ADD_A_d8,
        ADD_A_HL,
        ADD_A_r(Register),
        INC_r(Register),
        LD_A_a8,
        LD_A_a16,
        LD_A_C,
        LD_A_HLD,
        LD_A_HLI,
        LD_A_rp(RegisterPair),
        LD_a8_A,
        LD_a16_A,
        LD_C_A,
        LD_HL_d8,
        LD_HL_r(Register),
        LD_HLD_A,
        LD_HLI_A,
        LD_r_d8(Register),
        LD_r_HL(Register),
        LD_rp_A(RegisterPair),
        LD_rp_d16(RegisterPair),
        LD_SP_d16,
        NOP,
        SBC_A_d8,
        SBC_A_HL,
        SBC_A_r(Register),
        SUB_d8,
        SUB_HL,
        SUB_r(Register),
        Unknown,
    }

    impl Instruction {
        pub fn from_byte(byte: u8) -> Instruction {
            use registers::{Register::*, RegisterPair::*};

            match byte {
                0x00 => NOP,
                0x01 => LD_rp_d16(BC),
                0x02 => LD_rp_A(BC),
                0x04 => INC_r(B),
                0x06 => LD_r_d8(B),
                0x0A => LD_A_rp(BC),
                0x0C => INC_r(C),
                0x0E => LD_r_d8(C),
                0x11 => LD_rp_d16(DE),
                0x12 => LD_rp_A(DE),
                0x14 => INC_r(D),
                0x16 => LD_r_d8(D),
                0x1A => LD_A_rp(DE),
                0x1C => INC_r(E),
                0x1E => LD_r_d8(E),
                0x21 => LD_rp_d16(HL),
                0x22 => LD_HLI_A,
                0x24 => INC_r(H),
                0x26 => LD_r_d8(H),
                0x2A => LD_A_HLI,
                0x2C => INC_r(L),
                0x2E => LD_r_d8(L),
                0x31 => LD_SP_d16,
                0x32 => LD_HLD_A,
                0x36 => LD_HL_d8,
                0x3A => LD_A_HLD,
                0x3C => INC_r(A),
                0x3E => LD_r_d8(A),
                0x46 => LD_r_HL(B),
                0x4E => LD_r_HL(C),
                0x56 => LD_r_HL(D),
                0x5E => LD_r_HL(E),
                0x66 => LD_r_HL(H),
                0x6E => LD_r_HL(L),
                0x70 => LD_HL_r(B),
                0x71 => LD_HL_r(C),
                0x72 => LD_HL_r(D),
                0x73 => LD_HL_r(E),
                0x74 => LD_HL_r(H),
                0x75 => LD_HL_r(L),
                0x77 => LD_HL_r(A),
                0x7E => LD_r_HL(A),
                0x80 => ADD_A_r(B),
                0x81 => ADD_A_r(C),
                0x82 => ADD_A_r(D),
                0x83 => ADD_A_r(E),
                0x84 => ADD_A_r(H),
                0x85 => ADD_A_r(L),
                0x86 => ADD_A_HL,
                0x87 => ADD_A_r(A),
                0x88 => ADC_A_r(B),
                0x89 => ADC_A_r(C),
                0x8A => ADC_A_r(D),
                0x8B => ADC_A_r(E),
                0x8C => ADC_A_r(H),
                0x8D => ADC_A_r(L),
                0x8E => ADC_A_HL,
                0x8F => ADC_A_r(A),
                0x90 => SUB_r(B),
                0x91 => SUB_r(C),
                0x92 => SUB_r(D),
                0x93 => SUB_r(E),
                0x94 => SUB_r(H),
                0x95 => SUB_r(L),
                0x96 => SUB_HL,
                0x97 => SUB_r(A),
                0x98 => SBC_A_r(B),
                0x99 => SBC_A_r(C),
                0x9A => SBC_A_r(D),
                0x9B => SBC_A_r(E),
                0x9C => SBC_A_r(H),
                0x9D => SBC_A_r(L),
                0x9E => SBC_A_HL,
                0x9F => SBC_A_r(A),
                0xC6 => ADD_A_d8,
                0xCE => ADC_A_d8,
                0xD6 => SUB_d8,
                0xDE => SBC_A_d8,
                0xE0 => LD_a8_A,
                0xE2 => LD_C_A,
                0xEA => LD_a16_A,
                0xF0 => LD_A_a8,
                0xF2 => LD_A_C,
                0xFA => LD_A_a16,
                _ => Unknown,
            }
        }
    }
